<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
#Start Developing iOS Apps (Swift)
#[Getting Started](https://developer.apple.com/library/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/index.html#//apple_ref/doc/uid/TP40015214-CH2-SW1)
#Swift编程指南之入门
##快速了解 
*Swift编程指南*是一篇优秀的关于如何创建一个运行在iPhone和iPad设备上的应用的入门指南。观看增加的这一套文章把它作为指南会介绍给你如何去创建你的第一个应用——包括相关的工具，主要的概念和将会使你的学习之路更容易的最好的实践。
 每一篇文章都包含有一个教程和相关概念的信息，这些概念需要你之后去完整的了解它。这个教程以每一篇文章互相联系为基础,每一篇文章就是你最后创建的一个简单真实的IOS应用的每一步过程。  
当你看完这个教程创建了应用，你将会学习一些关于IOS应用开发的概念，获得对*Swift程序语言*的比较深入的了解，使你熟悉了苹果的*集成开发环境*（IDE）Xcode的许多有价值的特征。
###关于本教程
在这个教程中，你将会创建一个简单的叫做FoodTracker的美食记录应用。这个应用会展示一个美食列表，列表的每个记录包括美食的名字，评分和照片。用户可以增加一个新的美食记录，删除和编辑一个已经存在的美食记录。不管是增加或编辑一个已经存在的美食记录，都会使用户们导航到不同的界面，这些界面有美食记录的指定的名字，照片和评分。  
你的第一个教程是关于playground，它是Xcode的一种文件类型，它可以让你立马得到你编写的代码的结果。你可以下载playground文件，使用Xcode打开它，然后使用它去熟悉Swift语言的一些关键概念。  
剩下的每一个教程都会伴随一个Xcode工程文件展示关于教程的例子，这些代码和接口你能在每个教程的结束找到。在你阅读结束每个教程，你可以去下载这个工程文件然后去用你的代码检查是否跟它不一样。
###需要的工具
开发这个教程中的IOS应用需要使用最新的技术规范，你还需要苹果电脑（操作系统最少是OS X 10.10）运行最新版本的Xcode程序。Xcode包括你去设计、开发和调试IOS应用的所有特性。Xcode也包含IOS的SDK，这个Xcode中的SDK包括对于IOS开发你所需要的特有的工具，编译器和框架。  
可以从你的苹果电脑中的苹果商店免费的下载最新版本的Xcode。  

**下载最新版本的Xcode**  

* 1.在你的苹果电脑中打开App Store(默认在Dock中)
* 2.在顶部右边角落的搜索栏中输入*Xcode*，然后按下回车键。  
 第一个搜索结果就是Xcode应用。
* 3.点击获取按钮，然后点击安装按钮。
* 4.当有输入Apple ID和密码的提示框时，输入你自己的账号。
  Xcode会下载到你的`/Applications`的目录下。
>**重要**  
这个教程使用的是Xcode7.0和IOS SDK9.0。确保你的使用的Xcode版本和IOS SDK版本跟教程的一样去完成教程的指南  

让我们开始吧！
***
##学习关于Swift语言的要点  
你的第一个教程是以引导的形式展现给你关于Swift语言的playground，它是一种文件类型，可以让你跟代码互相交互，当你在Xcode中只要修改代码，它就会马上把结果呈现给你。Playgrounds文件在用来学习和做实验方面是很优秀的，这第一篇教程会帮助你快速的得到Swift的基本的概念。
>**提示**  
在Xcode中打开教程提供的*playground*学习会是最好的经验  
[下载Playground](https://developer.apple.com/sample-code/swift/downloads/Start-Dev-iOS-Apps-01.zip)  

###学习目标
当你学习完这篇教程，你将会知道以下知识点：

* 区分常量和变量的这两者的不同
* 知道什么时候用隐式声明和什么时候显式声明
* 理解使用可选和可选绑定的好处
* 区分可选和隐式解析可选的不同
* 理解条件语句的目的和循环
* 使用`switch`语句去解决出现二种情况以上的条件分支
* 在条件语句中使用`where`从句去增加额外的约束
* 区分功能，方法，和初始化的不同
* 区分类，结构体和枚举的不同
* 理解继承语法（在后面会用到的很基础的概念）和协议遵守语法
* 通过使用Xcode的快速帮助（按住`Option`键去点击）快捷的确定不知道的类型和找到额外的信息
* 导入和使用`UIKit`框架
###基本类型
*常量*的值是在第一次声明之后就一直停留在相同的值，而*变量*的值是能改变。常量被称为不可改变的量，意外着它不能被改变，而变量是可变的。如果你知道在你的代码中有一个不会需要改变的值，声明它为常量而不是变量。  
使用`let`声明一个常量，使用`var`声明一个变量.  
>  `var myVariable = 42`  
    `myVariable = 50`  
    `let myConstant = 42`  

每一个变量和常量在Swift中都有一种类型，但是你不用总是需要明确的把类型写出来。当你创建一个变量或常量时也提供了值，会让编译器去推测它的类型。在上面的例子中，编译器推测`myVariable `是整数类型因为它初始化的值是一个整数。这被称为类型推断。一旦变量或常量有了一个类型，这个类型是不能被改变的。  
如果初始化的值没有提供足够的信息（或者变量没有初始化的值），需要指定一个类型写在变量后面，用冒号和变量分隔开。  
>  ` let implicitInteger = 70`  
    `let implicitDouble = 70.0`  
    `let explicitDouble: Double = 70`  

[]() 
>**实验**  
在Xcode中按住`Option`键去点击变量或常量的名字能看到它的推测类型。尝试去敲一下上面的常量相关的代码。  

值从来不能隐式的转换为另一个类型。如果你需要转换一个值为一个不同的类型，就显示的把实例转换成所需要的类型。这里，展示了你怎么把`Int`类型转换成`String`类型。
> ` let label = "The width is "`  
   `let width = 94`  
   `let widthLabel = label + String(width)`

[]()
>**实验**  
尝试去移除最后一行里面转换为`String`类型的方法。你会得到什么错误？

有一个更简单的方法把值包括在字符串中：把值写在圆括号中，然后在圆括号之前写一个反斜杠(`\`)。这被称为字符串插入。
> `let apples = 3`  
   `let oranges = 5`  
   `let appleSummary = "I have \(apples) apples."`  
   `let fruitSummary = "I have \(apples + oranges) pieces of fruit."`

给值加上可选类型可能会导致丢失。一个可选值可能是一个有值的常量或者一个`nil`（没有值）常量，这`nil`常量预示着值是丢失的。写一个问号(`?`)在一个值的类型之后表示这个值是可选。
> `let optionalInt: Int? = 9`

从一个可选值得到其潜在的值，你需要解开它。你将会在最后学习到解包操作，但是最简单的方式就是*强制解包操作*(`!`)。仅仅在你确认其潜在的值不是空值(`nil`)的情况下才能使用这个解包操作。
> `let actualInt: Int = optionalInt!`

在Swift中可选值的使用是非常普遍的，当一个值在当时可能有也可能没有的很多情况下它是非常有用的。它们尤其是使用在尝试类型转换的时候。
> `var myString = "7"`  
   `var possibleInt = Int(myString)`  
   `print(possibleInt)`

在这个代码中，这个`possibleInt`的值是`7`，因为`myString `包含的这个值是一个整数类型。如果你把`myString`的值改变成某种不能转换成整数的类型，`possibleInt`就变成空值(`nil`)了。
> `myString = "banana"`  
   `possibleInt = Int(myString)`  
   `print(possibleInt)`

数组(`array`)是按照有序的顺序保持其含有的项的一种数据类型。使用方括号来创建数组，通过把数组的元素的索引写在方括号中来获取这些元素。数组的索引从`0`开始的。
> `var ratingList = ["Poor", "Fine", "Good", "Excellent"]`  
   `ratingList[1] = "OK"`  
   `ratingList`

使用初始化语法来创建实体数组。你将会在一会儿学习到更多关于初始化的。
>  `// Creates an empty array.(创建一个实体数组)`  
    `let emptyArray = [String]()`

你注意到的代码上面的是注释。注释是源代码文件中的一块文本，它不会作为程序的一部分被编译但会提供关于个人的代码块的背景或有用的信息。一行的注释出现需要在行的前面加上两个斜线(`//`)而多行的注释出现需要把注释设置在斜线加星号这样的两个之间(`/*...*/`)。你将会看到在本教程的从头到尾的源代码写的代码都包含有注释。  
*隐式解包可选*是一个可选值可以被看做是一个确定值的操作，除非是需要去解包这个可选值的时候才使用。这是因为*隐式解包可选*被假定为在它的值开始被设置之前总是有一个值，虽然这个值能改变。把问号(`?`)改成感叹号(`!`)就表明是*隐式解包可选*类型。  
你真的需要在你的自己的代码中去创建*隐式解包可选*。更常见的，你会看到它被用来保持在接口和源代码之间得输出口的联系(在接下来的课程你会学习到更多关于这个的)并且你能在`API`文档看到关于这个教程中提到的知识点的更多信息。
 
###控制流
`Swift`有两种类型的控制流语句。*控制语句*，比如`if`和`switch`这种在一段代码执行之前先检查条件是否正确的语句，正确就是条件的值被判断为·Boolean·类型的`true`。*循环语句*，比如`for-in`和`while`这种执行多次相同的一段代码的语句。  
`if`语句检查一个已经存在的条件是否是正确的，如果它是正确的，这个·if·语句判断执行语句里面的代码。你可以添加一个`else`分句使`if`语句去定义更复杂的行为。`else`语句也可以和`if`语句连在一起使用，或者单独使用，如果没有任何一个被连接的`if`语句的值被判断为`true`则这个`else`语句的行为被会被执行。
> `let number = 23`  
   `if number < 10 {`  
        `print("The number is small")`  
   `} else if number > 100 {`  
        `print("The number is pretty big")`  
   `} else {`  
        `print("The number is between 10 and 100")`  
   `}`  

[]() 
> **实验**  
把`number`改变成不同的整数(`integer`)值去看看对打印有什么影响。

控制语句能在一个程序中被嵌套为复杂和有趣的语句。这有一个例子，是`if`语句和`else`分支语句被被嵌套在`for-in`语句(按照集合中元素的顺序，一个又一个的迭代元素)中  
> `let individualScores = [75, 43, 103, 87, 12]`  
   `var teamScore = 0`  
   `for score in individualScores {`  
   ` if score > 50 {`  
       ` teamScore += 3`   
   ` } else {`  
        `teamScore += 1`  
    `}`  
 `}`  
 `print(teamScore)`  

在`if`语句中使用*可选绑定*去检查可选是否包含有值。
> `var optionalName: String? = "John Appleseed"`  
   `var greeting = "Hello!"`  
   `if let name = optionalName {`  
    `greeting = "Hello, \(name)"`  
`}`

[]() 
> **实验**  
把`optionalName`的值改为空(`nil`)。你会得到什么样的`getting`？增加一个如果`optionalName`是空的情况的`else`分支语句去设置不同的`getting`。  
 
如果可选的值是空`nil`，这个条件是假(`false`)，那么括弧中的代码会被跳过。否则，这个可选值被解包然后被分配给在`let`之后的常量，使这个被解包的值可被代码块的里面获得的。  
你可以使用一个单一的`if`语句去绑定多个值，一个`where`分支语句可以被增加为控制语句的更大范围的一种情况。在下面这个例子中，`if`语句的执行仅仅在它绑定的所有的值是正确的和所有的条件是匹配成功的。
> `var optionalHello: String? = "Hello"`  
   `if let hello = optionalHello where hello.hasPrefix("H"), let name =   optionalName {`  
    `greeting = "\(hello), \(name)"`  
`}`  

`switch`语句在`swift`中是十分强大的。一个`switch`语句支持任何类型的数据和各种各样的比较判断，并不会限制数据的类型为整数和限制相等的语句。这下面这个例子中，这个`switch`语句传入的字符串变量`vegetable`的值，然后与`switch`语句的每个`case`的值进行匹配，最后执行匹配成功的那个`case`。
> `let vegetable = "red pepper"`  
`switch vegetable {`  
`case "celery":`  
    `let vegetableComment = "Add some raisins and make ants on a log."`  
`case "cucumber", "watercress":`  
   `let vegetableComment = "That would make a good tea sandwich."`  
`case let x where x.hasSuffix("pepper"):`  
    `let vegetableComment = "Is it a spicy \(x)?"`  
`default:`  
    `let vegetableComment = "Everything tastes good in soup."`  
}`    

[]() 
> **实验**  
尝试移除`default`情况。你会得到什么错误？  

注意常量(`let`)怎么在一个模式中被分配值，然后用模式的一部分去比较一个恒定的值。就像在`if`语句一样，一个`where`分支语句可以被增加为控制语句的更大范围的一种情况。但是跟`if`语句不一样的，一个`switch`语句有很多被逗号分隔开的条件，当其中任何一个条件是匹配成功就会被执行。  
在执行被匹配的`switch`分支语句内的代码的时候，这个程序从`switch`语句退出。执行并不会继续到下一个分支语句，因此你不需要在每个分支语句代码结尾写额外的退出代码退出这个`switch`语句。  
`switch`语句必须写详细完整。一个默认的分支语句是需要的，除非这个背景是很清楚的，它的每个可能的分支都考虑满意。例如`switch`语句是在开关枚举。这个需求确定这个`switch`语句的其中一个分支总是会被执行。   
你可以使用`Range`来保持在循环中的索引。使用半开区间操作(`half-open range operator`(`..<`))去循环一个区间中的的索引。   
>`var firstForLoop = 0  
 for i in 0..< 4 {  
firstForLoop += i  
}  
print(firstForLoop) ` 

这个半开区间操作(`..<`)不包括这个上面的数字，因此这个循环区间从`0`到`3`总的有四个循环迭代。使用闭区间操作(`closed range operator`(`...`))使循环的区间包括所有的值。  
> `var secondForLoop = 0  
  for _ in 0...4 {  
 secondForLoop += 1  
}  
print(secondForLoop)`

这个循环区间从`0`到`4`总的有5个循环迭代。这个`_`下划线代表是一个通配符,当你不需要知道当前正在执行的循环怎么迭代的时候你可以使用这个通配符 。

### 函数和方法
一个函数是一个可重复使用,能用简称命名一块代码然后能在程序的许多地方通过简称使用。  
使用`func`去声明一个函数。一个函数声明可以报考空参数或者很多参数，写作`名字(name)`:`类型(Type)`是额外的信息块，这个信息当函数被调用的时候必须把它传递进函数中。可选，一个函数有一个返回类型，写在`->`之后，标志这个函数返回的结果类型。函数的实现在一对大括号(`{}`)里面。
>`func greet(name: String,day: String) -> String{  
return "Hello \(name), today is \(day)."  
}`  

调用一个函数通过它的名字和在括号里面的实参列表(传递的值的类型必须和函数的形参的类型符合)。当你调用一个函数，你传递的第一个实参的值不用写它的名字，而之后传递的实参的值要带着它的名字。
>`greet("Anna", day: "Thesday")  
greet("Bob", day: "Friday")  
greet("Charlie", day: "a nice day")`

函数定义中在一个特定类型中被叫做方法(`method`)。方法被定义在类型中，跟类型有着明确地联系，仅仅能被类型调用(或者一个子类，一会你会学习到子类相关的)。在前面的`switch`语句的例子中，你看到一个叫`hasSuffix()`的方法被定义在`String`类型中，这里再次展示了它的使用:
>`let exampleString = "hello"  
if exampleString.hasSuffix("lo")  {  
print("ends in lo")  
}`

就像你看到的，你可以使用这个点语法调用方法。当你调用一个方法，你传递第一个实参不需要写它的名字，而之后的每一个实参都要带着它的名字。例如，在`Array`类型中的这个方法带了两个形参，你仅仅在传递第二个实参的时候带着它的名字：
>`var array = ["apple", "banana", "dragonfruit"]  
array.insert("cherry", atIndex: 2)  
array`

###类和构造器
在面向对象程序中，这个程序的行为是大部分是基于两个对象间的相互作用。一个对象是一个类的实例，实例被认为做是对象的一个蓝图。类以属性的形式存储关于他们自己的额外的信息并且用方法定义它们的行为。  
使用跟在`class`之后的类名去定义一个类。在类里面有一个属性声明，除了在类中的上下文之外都可以使用一样的方式可以写常量或变量声明。同样，方法和函数的声明是同样的写法。这个例子声明了一个`Shape`类含有一个`numberOfSides`属性和一个`simpleDescription`方法。
>`calss Shape {  
var numberOfSides = 0  
func simpleDescription() -> String{  
 return "A shape with \() sides."  
}`

通过把括号放在类名之后去创建一个类的实例——对象。使用点语法获取这个实例的属性和方法。这里，`shape`是一个对象是`Shape`类的一个实例。
>`var shape = Shape()  
shape.simpleDescription = 7  
var shapeDescription = shape.simpleDescription()  `

这个`Shape`类遗漏一些重要的事：一个构造器(initializer)。构造器是一个准备一个类的一个实例去使用的方法，它涉及设置每个属性的初始化值和执行一些其他的建立。使用`init`去创建一个初始化方法。这个例子定义了一个新的类，`NamedShape`，这个有一个构造器含有一个形参`name`。
>`class NamedShape  {
var numberOfSides  = 0  
var name:String      
init(name:String){  
self.name = name  
}
func simpleDescription() -> String {  
return "A shape with \(numberOfSides ) sides.  
}  
}"`

这里面指出在构造器中怎么使用`self`去区分属性`name`和来自参数的`name`。每个属性都需要值分配——不管是在声明的时候(就像`numberOfSides `)或者是在构造器里面(就像`name`)。  
你不能通过写`init`来调用构造器；你可以通过在类名之后接上括号，在括号里放入适当的参数来调用构造器。当你调用构造器的时候，你你需要包含所有的参数名和它们对应的值。  
>`let nameShape = NamedShape(name: " mynamed shape")`  

类继承它们父类的行为。一个类从别的类继承行为这个类被称为子类，父类被称为超类。子类通过冒号分隔在它们的类名之后的它们的父类的类名。一个类仅仅能从一个父类继承，尽管这个父类可以从另一个相对于它的父类继承等等，结果就是产生了类的层次(`a class hierarchy`)。  
子类中的方法覆盖这个超类的方法被标记为`override`——不经意的覆盖一个方法，除了`override`标记，都会被编译器检查作为一个错误。这个编译器也检查`override`方法在超类实际上并没有对应的任何一个方法。  
这个例子定义这个`Square`类，一个`NamedShape`的子类。
>`class Square: NamedShare {  
var sideLength:Double  
init(sideLength:Double, name:String) {  
self.sideLength = sideLength  
super.init(name: name)  
numberOfSides = 4  
}  
func area() -> Double {  
return sideLength * sideLength  
}  
override func simpleDescription() -> String {  
return "A square with sides of lenth \(sideLength )."  

}  
}  
let testSquare = Square(sideLength: 5.2, name: "my test square")  
testSquare.area()   
testSquare.simpleDescription() `

指出这个`Square`类的构造器有三个不同的步骤：  

* 1.设置`Square`子类声明的属性的值。
* 2.调用`NamedShare`父类的构造器。
* 3.改变在`NamedShare`父类中定义的属性的值。一些额外的步骤工作有使用方法，获取属性方法或者属性方法也在这一步实现。  

有时候，初始化一个对象需要去做失败处理，例如当供给参数的值是超过参数的某些范围得时候，或者当预期的数据却是遗漏的时候。可能无法成功构造对象的构造器被叫做可失败构造器(failable initializers)。一个可失败构造器在初始化后返回空(`nil`)。使用`init?`声明一个可失败构造器。  
>`class Square: NamedShare {  
var sideLength:Double  
init(sideLength:Double, name:String) {  
self.sideLength = sideLength  
super.init(name: name)  
numberOfSides = 4  
}  
func area() -> Double {  
return sideLength * sideLength  
}  
override func simpleDescription() -> String {  
return "A square with sides of lenth \(sideLength )."  

}  
}  
let testSquare = Square(sideLength: 5.2, name: "my test square")  
testSquare.area()   
testSquare.simpleDescription() `

指出这个`Square`类的构造器有三个不同的步骤：  

* 1.设置`Square`子类声明的属性的值。
* 2.调用`NamedShare`父类的构造器。
* 3.改变在`NamedShare`父类中定义的属性的值。一些额外的步骤工作有使用方法，获取属性方法或者属性方法也在这一步实现。  

有时候，初始化一个对象需要去做失败处理，例如当供给参数的值是超过参数的某些范围得时候，或者当预期的数据却是遗漏的时候。可能无法成功构造对象的构造器被叫做可失败构造器(failable initializers)。一个可失败构造器在初始化后返回空(`nil`)。使用`init?`声明一个可失败构造器。

>`
class Circle: NamedShape {  
    var radius: Double  
    init?(radius: Double, name: String) {  
      self.radius = radius   
      super.init(name: name)  
      numberOfSides = 1  
      if radius <= 0 {  
          return nil  
      }   
  }  
  override func simpleDescription() -> String {  
     return "Acircle with  a radius of \(radius)."  
  }  
}  
let successfulCircle = Circle (radius: 4.2, name:"successful circle")  
let failedCircle = Circle(radius: -7, name:"failed circle")  `  

初始化还可以有许多与它相关连的关键字。一个`特定的初始化`不需要任何关键字。初始化作为扮演初始化一个类的其中一个主要的角色；任何类里面的初始化必须最终通过一个特定的初始化来调用。  
这个`convenience`关键字















<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<h1 id="startdevelopingiosappsswift">Start Developing iOS Apps (Swift)</h1>

<h1 id="gettingstartedhttpsdeveloperapplecomlibraryiosreferencelibrarygettingstarteddevelopiosappsswiftindexhtmlapple_refdocuidtp40015214ch2sw1"><a href="https://developer.apple.com/library/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/index.html#//apple_ref/doc/uid/TP40015214-CH2-SW1">Getting Started</a></h1>

<h1 id="swift">Swift编程指南之入门</h1>

<h2 id="">快速了解</h2>

<p><em>Swift编程指南</em>是一篇优秀的关于如何创建一个运行在iPhone和iPad设备上的应用的入门指南。观看增加的这一套文章把它作为指南会介绍给你如何去创建你的第一个应用——包括相关的工具，主要的概念和将会使你的学习之路更容易的最好的实践。
 每一篇文章都包含有一个教程和相关概念的信息，这些概念需要你之后去完整的了解它。这个教程以每一篇文章互相联系为基础,每一篇文章就是你最后创建的一个简单真实的IOS应用的每一步过程。 <br>
当你看完这个教程创建了应用，你将会学习一些关于IOS应用开发的概念，获得对<em>Swift程序语言</em>的比较深入的了解，使你熟悉了苹果的<em>集成开发环境</em>（IDE）Xcode的许多有价值的特征。</p>

<h3 id="">关于本教程</h3>

<p>在这个教程中，你将会创建一个简单的叫做FoodTracker的美食记录应用。这个应用会展示一个美食列表，列表的每个记录包括美食的名字，评分和照片。用户可以增加一个新的美食记录，删除和编辑一个已经存在的美食记录。不管是增加或编辑一个已经存在的美食记录，都会使用户们导航到不同的界面，这些界面有美食记录的指定的名字，照片和评分。 <br>
你的第一个教程是关于playground，它是Xcode的一种文件类型，它可以让你立马得到你编写的代码的结果。你可以下载playground文件，使用Xcode打开它，然后使用它去熟悉Swift语言的一些关键概念。 <br>
剩下的每一个教程都会伴随一个Xcode工程文件展示关于教程的例子，这些代码和接口你能在每个教程的结束找到。在你阅读结束每个教程，你可以去下载这个工程文件然后去用你的代码检查是否跟它不一样。</p>

<h3 id="">需要的工具</h3>

<p>开发这个教程中的IOS应用需要使用最新的技术规范，你还需要苹果电脑（操作系统最少是OS X 10.10）运行最新版本的Xcode程序。Xcode包括你去设计、开发和调试IOS应用的所有特性。Xcode也包含IOS的SDK，这个Xcode中的SDK包括对于IOS开发你所需要的特有的工具，编译器和框架。 <br>
可以从你的苹果电脑中的苹果商店免费的下载最新版本的Xcode。  </p>

<p><strong>下载最新版本的Xcode</strong>  </p>

<ul>
<li>1.在你的苹果电脑中打开App Store(默认在Dock中)</li>
<li>2.在顶部右边角落的搜索栏中输入<em>Xcode</em>，然后按下回车键。 <br>
第一个搜索结果就是Xcode应用。</li>
<li>3.点击获取按钮，然后点击安装按钮。</li>
<li>4.当有输入Apple ID和密码的提示框时，输入你自己的账号。
Xcode会下载到你的<code>/Applications</code>的目录下。


<blockquote>
  <p><strong>重要</strong> <br>
  这个教程使用的是Xcode7.0和IOS SDK9.0。确保你的使用的Xcode版本和IOS SDK版本跟教程的一样去完成教程的指南  </p></blockquote></li>
  </ul>
  让我们开始吧！<p></p>


<hr>




<h2 id="swift">学习关于Swift语言的要点</h2>

你的第一个教程是以引导的形式展现给你关于Swift语言的playground，它是一种文件类型，可以让你跟代码互相交互，当你在Xcode中只要修改代码，它就会马上把结果呈现给你。Playgrounds文件在用来学习和做实验方面是很优秀的，这第一篇教程会帮助你快速的得到Swift的基本的概念。


<blockquote>
  <p><strong>提示</strong> <br>
  在Xcode中打开教程提供的<em>playground</em>学习会是最好的经验 <br>
  <a href="https://developer.apple.com/sample-code/swift/downloads/Start-Dev-iOS-Apps-01.zip">下载Playground</a>  </p>
</blockquote>

<h3 id="">学习目标</h3>

当你学习完这篇教程，你将会知道以下知识点：

<ul>
<li>区分常量和变量的这两者的不同</li>
<li>知道什么时候用隐式声明和什么时候显式声明</li>
<li>理解使用可选和可选绑定的好处</li>
<li>区分可选和隐式解析可选的不同</li>
<li>理解条件语句的目的和循环</li>
<li>使用<code>switch</code>语句去解决出现二种情况以上的条件分支</li>
<li>在条件语句中使用<code>where</code>从句去增加额外的约束</li>
<li>区分功能，方法，和初始化的不同</li>
<li>区分类，结构体和枚举的不同</li>
<li>理解继承语法（在后面会用到的很基础的概念）和协议遵守语法</li>
<li>通过使用Xcode的快速帮助（按住<code>Option</code>键去点击）快捷的确定不知道的类型和找到额外的信息</li>
<li>导入和使用<code>UIKit</code>框架</li>
</ul>

<h3 id="">基本类型</h3>

<p><em>常量</em>的值是在第一次声明之后就一直停留在相同的值，而<em>变量</em>的值是能改变。常量被称为不可改变的量，意外着它不能被改变，而变量是可变的。如果你知道在你的代码中有一个不会需要改变的值，声明它为常量而不是变量。 <br>
使用<code>let</code>声明一个常量，使用<code>var</code>声明一个变量.  </p>

<blockquote>
  <p><code>var myVariable = 42</code> <br>
      <code>myVariable = 50</code> <br>
      <code>let myConstant = 42</code>  </p>
</blockquote>

<p>每一个变量和常量在Swift中都有一种类型，但是你不用总是需要明确的把类型写出来。当你创建一个变量或常量时也提供了值，会让编译器去推测它的类型。在上面的例子中，编译器推测<code>myVariable</code>是整数类型因为它初始化的值是一个整数。这被称为类型推断。一旦变量或常量有了一个类型，这个类型是不能被改变的。 <br>
如果初始化的值没有提供足够的信息（或者变量没有初始化的值），需要指定一个类型写在变量后面，用冒号和变量分隔开。  </p>

<blockquote>
  <p><code>let implicitInteger = 70</code> <br>
      <code>let implicitDouble = 70.0</code> <br>
      <code>let explicitDouble: Double = 70</code>  </p>
</blockquote>

<p><a href=""></a> </p>

<blockquote>
  <p><strong>实验</strong> <br>
  在Xcode中按住<code>Option</code>键去点击变量或常量的名字能看到它的推测类型。尝试去敲一下上面的常量相关的代码。  </p>
</blockquote>

<p>值从来不能隐式的转换为另一个类型。如果你需要转换一个值为一个不同的类型，就显示的把实例转换成所需要的类型。这里，展示了你怎么把<code>Int</code>类型转换成<code>String</code>类型。</p>

<blockquote>
  <p><code>let label = "The width is "</code> <br>
     <code>let width = 94</code> <br>
     <code>let widthLabel = label + String(width)</code></p>
</blockquote>

<p><a href=""></a></p>

<blockquote>
  <p><strong>实验</strong> <br>
  尝试去移除最后一行里面转换为<code>String</code>类型的方法。你会得到什么错误？</p>
</blockquote>

<p>有一个更简单的方法把值包括在字符串中：把值写在圆括号中，然后在圆括号之前写一个反斜杠(<code>\</code>)。这被称为字符串插入。</p>

<blockquote>
  <p><code>let apples = 3</code> <br>
     <code>let oranges = 5</code> <br>
     <code>let appleSummary = "I have \(apples) apples."</code> <br>
     <code>let fruitSummary = "I have \(apples + oranges) pieces of fruit."</code></p>
</blockquote>

<p>给值加上可选类型可能会导致丢失。一个可选值可能是一个有值的常量或者一个<code>nil</code>（没有值）常量，这<code>nil</code>常量预示着值是丢失的。写一个问号(<code>?</code>)在一个值的类型之后表示这个值是可选。</p>

<blockquote>
  <p><code>let optionalInt: Int? = 9</code></p>
</blockquote>

<p>从一个可选值得到其潜在的值，你需要解开它。你将会在最后学习到解包操作，但是最简单的方式就是<em>强制解包操作</em>(<code>!</code>)。仅仅在你确认其潜在的值不是空值(<code>nil</code>)的情况下才能使用这个解包操作。</p>

<blockquote>
  <p><code>let actualInt: Int = optionalInt!</code></p>
</blockquote>

<p>在Swift中可选值的使用是非常普遍的，当一个值在当时可能有也可能没有的很多情况下它是非常有用的。它们尤其是使用在尝试类型转换的时候。</p>

<blockquote>
  <p><code>var myString = "7"</code> <br>
     <code>var possibleInt = Int(myString)</code> <br>
     <code>print(possibleInt)</code></p>
</blockquote>

<p>在这个代码中，这个<code>possibleInt</code>的值是<code>7</code>，因为<code>myString</code>包含的这个值是一个整数类型。如果你把<code>myString</code>的值改变成某种不能转换成整数的类型，<code>possibleInt</code>就变成空值(<code>nil</code>)了。</p>

<blockquote>
  <p><code>myString = "banana"</code> <br>
     <code>possibleInt = Int(myString)</code> <br>
     <code>print(possibleInt)</code></p>
</blockquote>

<p>数组(<code>array</code>)是按照有序的顺序保持其含有的项的一种数据类型。使用方括号来创建数组，通过把数组的元素的索引写在方括号中来获取这些元素。数组的索引从<code>0</code>开始的。</p>

<blockquote>
  <p><code>var ratingList = ["Poor", "Fine", "Good", "Excellent"]</code> <br>
     <code>ratingList[1] = "OK"</code> <br>
     <code>ratingList</code></p>
</blockquote>

<p>使用初始化语法来创建实体数组。你将会在一会儿学习到更多关于初始化的。</p>

<blockquote>
  <p><code>// Creates an empty array.(创建一个实体数组)</code> <br>
      <code>let emptyArray = [String]()</code></p>
</blockquote>

<p>你注意到的代码上面的是注释。注释是源代码文件中的一块文本，它不会作为程序的一部分被编译但会提供关于个人的代码块的背景或有用的信息。一行的注释出现需要在行的前面加上两个斜线(<code>//</code>)而多行的注释出现需要把注释设置在斜线加星号这样的两个之间(<code>/*...*/</code>)。你将会看到在本教程的从头到尾的源代码写的代码都包含有注释。 <br>
<em>隐式解包可选</em>是一个可选值可以被看做是一个确定值的操作，除非是需要去解包这个可选值的时候才使用。这是因为<em>隐式解包可选</em>被假定为在它的值开始被设置之前总是有一个值，虽然这个值能改变。把问号(<code>?</code>)改成感叹号(<code>!</code>)就表明是<em>隐式解包可选</em>类型。 <br>
你真的需要在你的自己的代码中去创建<em>隐式解包可选</em>。更常见的，你会看到它被用来保持在接口和源代码之间得输出口的联系(在接下来的课程你会学习到更多关于这个的)并且你能在<code>API</code>文档看到关于这个教程中提到的知识点的更多信息。</p>

<h3 id="">控制流</h3>

<p><code>Swift</code>有两种类型的控制流语句。<em>控制语句</em>，比如<code>if</code>和<code>switch</code>这种在一段代码执行之前先检查条件是否正确的语句，正确就是条件的值被判断为·Boolean·类型的<code>true</code>。<em>循环语句</em>，比如<code>for-in</code>和<code>while</code>这种执行多次相同的一段代码的语句。 <br>
<code>if</code>语句检查一个已经存在的条件是否是正确的，如果它是正确的，这个·if·语句判断执行语句里面的代码。你可以添加一个<code>else</code>分句使<code>if</code>语句去定义更复杂的行为。<code>else</code>语句也可以和<code>if</code>语句连在一起使用，或者单独使用，如果没有任何一个被连接的<code>if</code>语句的值被判断为<code>true</code>则这个<code>else</code>语句的行为被会被执行。</p>

<blockquote>
  <p><code>let number = 23</code> <br>
     <code>if number &lt; 10 {</code> <br>
          <code>print("The number is small")</code> <br>
     <code>} else if number &gt; 100 {</code> <br>
          <code>print("The number is pretty big")</code> <br>
     <code>} else {</code> <br>
          <code>print("The number is between 10 and 100")</code> <br>
     <code>}</code>  </p>
</blockquote>

<p><a href=""></a> </p>

<blockquote>
  <p><strong>实验</strong> <br>
  把<code>number</code>改变成不同的整数(<code>integer</code>)值去看看对打印有什么影响。</p>
</blockquote>

<p>控制语句能在一个程序中被嵌套为复杂和有趣的语句。这有一个例子，是<code>if</code>语句和<code>else</code>分支语句被被嵌套在<code>for-in</code>语句(按照集合中元素的顺序，一个又一个的迭代元素)中  </p>

<blockquote>
  <p><code>let individualScores = [75, 43, 103, 87, 12]</code> <br>
     <code>var teamScore = 0</code> <br>
     <code>for score in individualScores {</code> <br>
     <code>if score &gt; 50 {</code> <br>
         <code>teamScore += 3</code> <br>
     <code>} else {</code> <br>
          <code>teamScore += 1</code> <br>
      <code>}</code> <br>
   <code>}</code> <br>
   <code>print(teamScore)</code>  </p>
</blockquote>

<p>在<code>if</code>语句中使用<em>可选绑定</em>去检查可选是否包含有值。</p>

<blockquote>
  <p><code>var optionalName: String? = "John Appleseed"</code> <br>
     <code>var greeting = "Hello!"</code> <br>
     <code>if let name = optionalName {</code> <br>
      <code>greeting = "Hello, \(name)"</code> <br>
  <code>}</code></p>
</blockquote>

<p><a href=""></a> </p>

<blockquote>
  <p><strong>实验</strong> <br>
  把<code>optionalName</code>的值改为空(<code>nil</code>)。你会得到什么样的<code>getting</code>？增加一个如果<code>optionalName</code>是空的情况的<code>else</code>分支语句去设置不同的<code>getting</code>。  </p>
</blockquote>

<p>如果可选的值是空<code>nil</code>，这个条件是假(<code>false</code>)，那么括弧中的代码会被跳过。否则，这个可选值被解包然后被分配给在<code>let</code>之后的常量，使这个被解包的值可被代码块的里面获得的。 <br>
你可以使用一个单一的<code>if</code>语句去绑定多个值，一个<code>where</code>分支语句可以被增加为控制语句的更大范围的一种情况。在下面这个例子中，<code>if</code>语句的执行仅仅在它绑定的所有的值是正确的和所有的条件是匹配成功的。</p>

<blockquote>
  <p><code>var optionalHello: String? = "Hello"</code> <br>
     <code>if let hello = optionalHello where hello.hasPrefix("H"), let name =   optionalName {</code> <br>
      <code>greeting = "\(hello), \(name)"</code> <br>
  <code>}</code>  </p>
</blockquote>

<p><code>switch</code>语句在<code>swift</code>中是十分强大的。一个<code>switch</code>语句支持任何类型的数据和各种各样的比较判断，并不会限制数据的类型为整数和限制相等的语句。这下面这个例子中，这个<code>switch</code>语句传入的字符串变量<code>vegetable</code>的值，然后与<code>switch</code>语句的每个<code>case</code>的值进行匹配，最后执行匹配成功的那个<code>case</code>。</p>

<blockquote>
  <p><code>let vegetable = "red pepper"</code> <br>
  <code>switch vegetable {</code> <br>
  <code>case "celery":</code> <br>
      <code>let vegetableComment = "Add some raisins and make ants on a log."</code> <br>
  <code>case "cucumber", "watercress":</code> <br>
     <code>let vegetableComment = "That would make a good tea sandwich."</code> <br>
  <code>case let x where x.hasSuffix("pepper"):</code> <br>
      <code>let vegetableComment = "Is it a spicy \(x)?"</code> <br>
  <code>default:</code> <br>
      <code>let vegetableComment = "Everything tastes good in soup."</code> <br>
  }`    </p>
</blockquote>

<p><a href=""></a> </p>

<blockquote>
  <p><strong>实验</strong> <br>
  尝试移除<code>default</code>情况。你会得到什么错误？  </p>
</blockquote>

<p>注意常量(<code>let</code>)怎么在一个模式中被分配值，然后用模式的一部分去比较一个恒定的值。就像在<code>if</code>语句一样，一个<code>where</code>分支语句可以被增加为控制语句的更大范围的一种情况。但是跟<code>if</code>语句不一样的，一个<code>switch</code>语句有很多被逗号分隔开的条件，当其中任何一个条件是匹配成功就会被执行。 <br>
在执行被匹配的<code>switch</code>分支语句内的代码的时候，这个程序从<code>switch</code>语句退出。执行并不会继续到下一个分支语句，因此你不需要在每个分支语句代码结尾写额外的退出代码退出这个<code>switch</code>语句。 <br>
<code>switch</code>语句必须写详细完整。一个默认的分支语句是需要的，除非这个背景是很清楚的，它的每个可能的分支都考虑满意。例如<code>switch</code>语句是在开关枚举。这个需求确定这个<code>switch</code>语句的其中一个分支总是会被执行。 <br>
你可以使用<code>Range</code>来保持在循环中的索引。使用半开区间操作(<code>half-open range operator</code>(<code>..&lt;</code>))去循环一个区间中的的索引。   </p>

<blockquote>
  <p><code>var firstForLoop = 0 <br>
   for i in 0..&lt; 4 { <br>
  firstForLoop += i <br>
  } <br>
  print(firstForLoop)</code> </p>
</blockquote>

<p>这个半开区间操作(<code>..&lt;</code>)不包括这个上面的数字，因此这个循环区间从<code>0</code>到<code>3</code>总的有四个循环迭代。使用闭区间操作(<code>closed range operator</code>(<code>...</code>))使循环的区间包括所有的值。  </p>

<blockquote>
  <p><code>var secondForLoop = 0 <br>
    for _ in 0...4 { <br>
   secondForLoop += 1 <br>
  } <br>
  print(secondForLoop)</code></p>
</blockquote>

<p>这个循环区间从<code>0</code>到<code>4</code>总的有5个循环迭代。这个<code>_</code>下划线代表是一个通配符,当你不需要知道当前正在执行的循环怎么迭代的时候你可以使用这个通配符 。</p>

<h3 id="">函数和方法</h3>

<p>一个函数是一个可重复使用,能用简称命名一块代码然后能在程序的许多地方通过简称使用。 <br>
使用<code>func</code>去声明一个函数。一个函数声明可以报考空参数或者很多参数，写作<code>名字(name)</code>:<code>类型(Type)</code>是额外的信息块，这个信息当函数被调用的时候必须把它传递进函数中。可选，一个函数有一个返回类型，写在<code>-&gt;</code>之后，标志这个函数返回的结果类型。函数的实现在一对大括号(<code>{}</code>)里面。</p>

<blockquote>
  <p><code>func greet(name: String,day: String) -&gt; String{ <br>
  return "Hello \(name), today is \(day)." <br>
  }</code>  </p>
</blockquote>

<p>调用一个函数通过它的名字和在括号里面的实参列表(传递的值的类型必须和函数的形参的类型符合)。当你调用一个函数，你传递的第一个实参的值不用写它的名字，而之后传递的实参的值要带着它的名字。</p>

<blockquote>
  <p><code>greet("Anna", day: "Thesday") <br>
  greet("Bob", day: "Friday") <br>
  greet("Charlie", day: "a nice day")</code></p>
</blockquote>

<p>函数定义中在一个特定类型中被叫做方法(<code>method</code>)。方法被定义在类型中，跟类型有着明确地联系，仅仅能被类型调用(或者一个子类，一会你会学习到子类相关的)。在前面的<code>switch</code>语句的例子中，你看到一个叫<code>hasSuffix()</code>的方法被定义在<code>String</code>类型中，这里再次展示了它的使用:</p>

<blockquote>
  <p><code>let exampleString = "hello" <br>
  if exampleString.hasSuffix("lo")  { <br>
  print("ends in lo") <br>
  }</code></p>
</blockquote>

<p>就像你看到的，你可以使用这个点语法调用方法。当你调用一个方法，你传递第一个实参不需要写它的名字，而之后的每一个实参都要带着它的名字。例如，在<code>Array</code>类型中的这个方法带了两个形参，你仅仅在传递第二个实参的时候带着它的名字：</p>

<blockquote>
  <p><code>var array = ["apple", "banana", "dragonfruit"] <br>
  array.insert("cherry", atIndex: 2) <br>
  array</code></p>
</blockquote>

<h3 id="">类和构造器</h3>

<p>在面向对象程序中，这个程序的行为是大部分是基于两个对象间的相互作用。一个对象是一个类的实例，实例被认为做是对象的一个蓝图。类以属性的形式存储关于他们自己的额外的信息并且用方法定义它们的行为。 <br>
使用跟在<code>class</code>之后的类名去定义一个类。在类里面有一个属性声明，除了在类中的上下文之外都可以使用一样的方式可以写常量或变量声明。同样，方法和函数的声明是同样的写法。这个例子声明了一个<code>Shape</code>类含有一个<code>numberOfSides</code>属性和一个<code>simpleDescription</code>方法。</p>

<blockquote>
  <p><code>calss Shape { <br>
  var numberOfSides = 0 <br>
  func simpleDescription() -&gt; String{ <br>
   return "A shape with \() sides." <br>
  }</code></p>
</blockquote>

<p>通过把括号放在类名之后去创建一个类的实例——对象。使用点语法获取这个实例的属性和方法。这里，<code>shape</code>是一个对象是<code>Shape</code>类的一个实例。</p>

<blockquote>
  <p><code>var shape = Shape() <br>
  shape.simpleDescription = 7 <br>
  var shapeDescription = shape.simpleDescription()</code></p>
</blockquote>

<p>这个<code>Shape</code>类遗漏一些重要的事：一个构造器(initializer)。构造器是一个准备一个类的一个实例去使用的方法，它涉及设置每个属性的初始化值和执行一些其他的建立。使用<code>init</code>去创建一个初始化方法。这个例子定义了一个新的类，<code>NamedShape</code>，这个有一个构造器含有一个形参<code>name</code>。</p>

<blockquote>
  <p><code>class NamedShape  {
  var numberOfSides  = 0 <br>
  var name:String <br>
  init(name:String){ <br>
  self.name = name <br>
  }
  func simpleDescription() -&gt; String { <br>
  return "A shape with \(numberOfSides ) sides. <br>
  } <br>
  }"</code></p>
</blockquote>

<p>这里面指出在构造器中怎么使用<code>self</code>去区分属性<code>name</code>和来自参数的<code>name</code>。每个属性都需要值分配——不管是在声明的时候(就像<code>numberOfSides</code>)或者是在构造器里面(就像<code>name</code>)。 <br>
你不能通过写<code>init</code>来调用构造器；你可以通过在类名之后接上括号，在括号里放入适当的参数来调用构造器。当你调用构造器的时候，你你需要包含所有的参数名和它们对应的值。  </p>

<blockquote>
  <p><code>let nameShape = NamedShape(name: " mynamed shape")</code>  </p>
</blockquote>

<p>类继承它们父类的行为。一个类从别的类继承行为这个类被称为子类，父类被称为超类。子类通过冒号分隔在它们的类名之后的它们的父类的类名。一个类仅仅能从一个父类继承，尽管这个父类可以从另一个相对于它的父类继承等等，结果就是产生了类的层次(<code>a class hierarchy</code>)。 <br>
子类中的方法覆盖这个超类的方法被标记为<code>override</code>——不经意的覆盖一个方法，除了<code>override</code>标记，都会被编译器检查作为一个错误。这个编译器也检查<code>override</code>方法在超类实际上并没有对应的任何一个方法。 <br>
这个例子定义这个<code>Square</code>类，一个<code>NamedShape</code>的子类。</p>

<blockquote>
  <p>`class Square: NamedShare { <br>
  var sideLength:Double <br>
  init(sideLength:Double, name:String) { <br>
  self.sideLength = sideLength <br>
  super.init(name: name) <br>
  numberOfSides = 4 <br>
  } <br>
  func area() -&gt; Double { <br>
  return sideLength * sideLength <br>
  } <br>
  override func simpleDescription() -&gt; String { <br>
  return "A square with sides of lenth (sideLength )."  </p>
</blockquote>

<p>} <br>
} <br>
let testSquare = Square(sideLength: 5.2, name: "my test square") <br>
testSquare.area() <br>
testSquare.simpleDescription() `</p>

<p>指出这个<code>Square</code>类的构造器有三个不同的步骤：  </p>

<ul>
<li>1.设置<code>Square</code>子类声明的属性的值。</li>
<li>2.调用<code>NamedShare</code>父类的构造器。</li>
<li>3.改变在<code>NamedShare</code>父类中定义的属性的值。一些额外的步骤工作有使用方法，获取属性方法或者属性方法也在这一步实现。  </li>
</ul>

<p>有时候，初始化一个对象需要去做失败处理，例如当供给参数的值是超过参数的某些范围得时候，或者当预期的数据却是遗漏的时候。可能无法成功构造对象的构造器被叫做可失败构造器(failable initializers)。一个可失败构造器在初始化后返回空(<code>nil</code>)。使用<code>init?</code>声明一个可失败构造器。  </p>

<blockquote>
  <p>`class Square: NamedShare { <br>
  var sideLength:Double <br>
  init(sideLength:Double, name:String) { <br>
  self.sideLength = sideLength <br>
  super.init(name: name) <br>
  numberOfSides = 4 <br>
  } <br>
  func area() -&gt; Double { <br>
  return sideLength * sideLength <br>
  } <br>
  override func simpleDescription() -&gt; String { <br>
  return "A square with sides of lenth (sideLength )."  </p>
</blockquote>

<p>} <br>
} <br>
let testSquare = Square(sideLength: 5.2, name: "my test square") <br>
testSquare.area() <br>
testSquare.simpleDescription() `</p>

<p>指出这个<code>Square</code>类的构造器有三个不同的步骤：  </p>

<ul>
<li>1.设置<code>Square</code>子类声明的属性的值。</li>
<li>2.调用<code>NamedShare</code>父类的构造器。</li>
<li>3.改变在<code>NamedShare</code>父类中定义的属性的值。一些额外的步骤工作有使用方法，获取属性方法或者属性方法也在这一步实现。  </li>
</ul>

<p>有时候，初始化一个对象需要去做失败处理，例如当供给参数的值是超过参数的某些范围得时候，或者当预期的数据却是遗漏的时候。可能无法成功构造对象的构造器被叫做可失败构造器(failable initializers)。一个可失败构造器在初始化后返回空(<code>nil</code>)。使用<code>init?</code>声明一个可失败构造器。</p>

<blockquote>
  <p><code>
  class Circle: NamedShape { <br>
      var radius: Double <br>
      init?(radius: Double, name: String) { <br>
        self.radius = radius <br>
        super.init(name: name) <br>
        numberOfSides = 1 <br>
        if radius &lt;= 0 { <br>
            return nil <br>
        } <br>
    } <br>
    override func simpleDescription() -&gt; String { <br>
       return "Acircle with  a radius of \(radius)." <br>
    } <br>
  } <br>
  let successfulCircle = Circle (radius: 4.2, name:"successful circle") <br>
  let failedCircle = Circle(radius: -7, name:"failed circle")</code>  </p>
</blockquote>

<p>初始化还可以有许多与它相关连的关键字。一个<code>特定的初始化</code>不需要任何关键字。初始化作为扮演初始化一个类的其中一个主要的角色；任何类里面的初始化必须最终通过一个特定的初始化来调用。 <br>
这个<code>convenience</code>关键字</p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "Swift编程指南之入门.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
